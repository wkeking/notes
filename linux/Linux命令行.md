# Linux命令行

## 什么是Linux

Linux可分为四个部分：

- Linux内核
- GNU工具
- 图形化桌面环境
- 应用软件

### Linux内核

Linux系统的核心是内核。内核控制着计算机系统上所有硬件和软件，在必要时分配硬件，并根据需要执行软件。

内核主要负责四中功能：

- 系统内存管理
- 软件程序管理
- 硬件设备管理
- 文件系统管理

#### 系统内存管理

内核不仅管理服务器上的可用物理内存，还可以创建和管理虚拟内存（即实际上不存在的内存）。

内核通过硬盘上的存储空间来实现虚拟内存，这块区域成为交换空间（swap space）。内核不断的在交换空间和实际物理内存之间反复交换虚拟内存中的内容。这使得系统以为它拥有比物理内存更多的可用内存。

#### 软件程序管理

Linux操作系统将运行中的程序成为进程。内核控制着Linux系统如何管理运行在系统上的所有进程。

内核创建了第一个进程（称为init进程）来启动系统上所有其他进程。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。

#### 硬件设备管理

任何Linux系统需要与之通信的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交换数据。

Linux系统将硬件设备当成特殊的文件，称为设备文件。

Linux为系统上的每个设备都创建一种称为节点的特殊文件。与设备的所有通信都通过设备节点完成。每个节点都有唯一的数值对供Linux内核识别它。数值对包括一个主设备号和一个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特定设备。

#### 文件系统管理

Linux内核支持通过不同类型的 文件系统从硬盘中读写数据。除了自有的诸多文件系统外，Linux还支持从其他操作系统采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持。

Linux内核采用虚拟文件系统（Virtual File System，VFS）作为和每个文件系统交互的接口。这为Linux内核同任何类型文件系统通信提供了一个标准接口。当每个文件系统都被挂载和使用时，VFS将信息都缓存在内存中。

### GNU工具

除了由内核控制硬件设备外，操作系统还需要工具来执行一些标准功能。

GNU组织开发了一套完整的开源的Unix工具。

将Linux内核和GNU操作系统工具整合起来，就产生了一款完整的、功能丰富的免费操作系统。

####核心GNU工具

GNU项目的主旨在于为Unix系统管理员设计出一套类似于Unix的环境。这个目标促使该项目抑制了很多常见的Unix系统命令行工具。供Linux系统使用的这组核心工具被称为coreutils（core utilities）软件包。

GNU coreutils软件包由三部分构成：

- 用以处理文件的工具
- 用以操作文件的工具
- 用以管理进程的工具

#### shell

GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。

shell包含了一组内部命令，用这些命令可以完成诸如复制文件、移动文件、重命名文件、显示和终止系统中正运行的程序等操作。shell也允许你在命令行提示符中输入程序的名称，它会将程序名传递给内核以启动它。

可以将多个shell命令放入文件中作为程序执行。这些文件被称作shell脚本。你在命令行上执行的任何命令都可放进一个shell脚本中作为一组命令执行。

## Linux文件系统

在Windows中，PC上安装的物理驱动器决定了文件的路径名。Windows会为每个物理驱动器分配一个盘符，每个驱动器都会有自己的目录结构，以便访问存储其中的文件。

Linux则采用了一种不同的方式。Linux将文件存储在单个目录结构中，这个目录被称为虚拟目录（virtual directory）。虚拟目录将安装在PC上的所有存储设备的文件路径纳入单个目录结构中。

Linux虚拟目录结构只包含一个称为根（root）目录的基础目录。根目录下的目录和文件会按照访问他们的目录路径一一列出。

Linux虚拟目录中比较复杂的部分是它如何协调管理各个存储设备。在Linux PC上安装的第一块硬盘称为根驱动器。根驱动器包含了虚拟目录的核心，其他目录都是从那里开始构建。

Linux会在根驱动器上创建一些特别的目录，我们称之为挂载点。挂载点虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中，然而实际上他们却存储在另外一个驱动器中。

|   目录   |              用途               |
| :----: | :---------------------------: |
|   /    |     虚拟目录的根目录。通常不会在这里存储文件      |
|  /bin  |      二进制目录，存放许多用户级的GNU工具      |
| /boot  |          启动目录，存放启动文件          |
|  /dev  |      设备目录，Linux在这里创建设备节点      |
|  /etc  |           系统配置文件目录            |
| /home  |      主目录，Linux在这里创建用户目录       |
|  /lib  |       库目录，存放系统和应用程序的库文件       |
| /media |      媒体目录，可移动媒体设备的常用挂载点       |
|  /mnt  |     挂载目录，另一个可移动媒体设备的常用挂载点     |
|  /opt  |     可选目录，常用于存放第三方软件包和数据文件     |
| /proc  |     进程目录，存放现有硬件及当前进程的相关信息     |
| /root  |          root用户的主目录           |
| /sbin  |     系统二进制目录，存放许多GNU管理员级工具     |
|  /run  |      运行目录，存放系统运作时的运行时数据       |
|  /srv  |       服务目录，存放本地服务的相关文件        |
|  /sys  |      系统目录，存放系统硬件信息的相关文件       |
|  /tmp  |    临时目录，可以在该目录中创建和删除临时工作文件    |
|  /usr  | 用户二进制文件，大量用户级GNU工具和数据文件都存储在这里 |
|  /var  |    可变目录，用以存放经常变化的文件，比如日志文件    |

## 基本的bash shell命令

### 文件和目录列表

#### 基本列表功能（ls）

显示当前目录下的文件和目录：

``` shell
ls
```

-F参数的ls命令区分文件和目录，在目录名后加了正斜线（/），在可执行文件后面加星号（*）：

```shell
ls -F
```

-a参数可以把隐藏文件和普通文件一起显示出来：

```shell
ls -a
```

-R参数叫做递归选项，它列出当前目录下包含的子目录中的文件：

```shell
ls -R
```

-i参数列出文件的inode编号（文件或目录的inode编号是一个用于标识的唯一数字，这个数字由内核分配给文件系统中的每一个对象）：

```shell
ls -i
```

#### 显示长列表

-l参数会产生长列表格式的输出，包含了目录中每个文件的更多相关信息：

```shell
ls -l
```

这种长列表格式的输出在每一行中列出了单个文件和目录。除了文件名，输出中还有其他有用信息。输出的第一行显示了在目录中包含的总块数。在此之后，每一行都包含了关于文件的下述信息：

- 文件类型，比如目录（d）、文件（-）、字符型文件（c）或块设备（b）；
- 文件的权限；
- 文件的硬链接总数；
- 文件属主的用户名；
- 文件属组的组名；
- 文件的大小（以字节为单位）；
- 文件的上次修改时间（要想查看文件的访问时间，加入另外一个参数：--time=atime）；
- 文件名或者目录名。

#### 过滤输出列表

ls命令支持在命令行中定义过滤器。他会用过滤器来决定应该在输出中显示哪些文件或目录。

```shell
ls -l my_script
```

ls命令能识别标准通配符，并在过滤器中用他们进行模式匹配：

- 问号（？）代表一个字符；
- 星号（*）代表零个或多个字符；
- 中括号（[]）代表在特定位置上可能出现的字符。

```shell
[ai]:可能出现a或者i
[a-i]:可能出现a到i范围内的字符
[!a]:将a排除在外
```

### 处理文件

#### 创建文件（touch）

创建空文件，并将你的用户名作为文件的属主：

```shell
touch filename
```

touch命令还可以用来改变文件的修改时间。

如果只想改变文件的访问时间，可用-a参数：

```shell
touch -a filename
```

#### 复制文件（cp）

在文件系统中将一个文件或目录从一个位置复制到另一个位置：

```shell
cp source destination
```

当source和destination参数都是文件名时，cp命令将源文件复制成一个新文件，并且以destination命名。新文件就像全新的文件一样，有新的修改时间。

-i选项作用是如果目标文件已存在，强制shell询问是否需要覆盖已有文件：

```shell
cp -i source destination
```

-R参数可以在一条命令中递归的复制整个目录中的内容：

```shell
cp -R source destination
```

#### 链接文件（ln）

如需要在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件和多个虚拟副本文件的方法。这种虚拟的副本就称为链接。链接是目录中指向文件真实位置的占位符。

在Linux中有两种不同类型的文件链接：

- 符号链接

符号链接是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号连接在一起的文件，彼此的内容并不相同。

```shell
ln -s data s_data
```

可以查看文件的inode编号，证明两个文件是完全不同的文件。可以将符号链接看做源文件的引用。

- 硬链接

硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是他们从根本上而言是同一个文件，inode编号一致。引用硬链接文件等同于引用了源文件。

```shell
ln data h_data
```

**备注：只能对处于同一存储媒体的文件创建硬链接。要想在不同存储媒体的文件之间创建连接，只能使用符号链接。**

#### 重命名文件（mv）

将文件和目录移动到另一个位置或重命名：

```shell
mv fall fzll
```

-i选项作用是如果目标文件已存在，强制shell询问是否需要覆盖已有文件：

```shell
mv -i fall fzll
```

#### 删除文件（rm）

```shell
rm file
```

-i命令参数提示你是不是要真的删除该文件：

```shell
rm -i file
```

-f参数强制删除：

```shell
rm -f file
```

### 处理目录

#### 创建目录（mkdir）

```shell
mkdir dir
```

-p参数可以同时创建多个目录和子目录：

```shell
mkdir -p a/b/c b
```

#### 删除目录（rmdir）

删除一个空目录：

```shell
rmdir dir
```

也可以在整个非空目录上使用rm命令。使用-r选项使得命令可以向下进入目录，删除其中的文件，然后再删除目录本身：

```shell
rm -r dir
```

### 查看文件内容

#### 查看文件类型（file）

file命令能够探测文件的内部，并决定文件是什么类型的：

```shell
file my_file
```

file不仅能确定文件中包含的文本信息，还能确定文本文件的字符编码。

#### 查看整个文件（cat、more、less）

1. cat

cat命令可以显示文本文件中所有数据：

```shell
cat file
```

-n参数会给所有的行加上行号：

```shell
cat -n file
```

-b参数只给有文本的行加上行号：

```shell
cat -b file
```

-T参数不让制表符出现，会用^I字符组合替换文本中的所有制表符：

```shell
cat -T file
```

2. more

more命令显示文本文件的内容，但会在显示每页数据之后停下来：

```shell
more file
```

more命令是分页工具。可以通过按空格键或回车键以逐行向前的方式浏览文本文件，按q退出。

3. less

less实为more命令的升级版：

```shell
less file
```

less命令能够识别上下键以及上下翻页键。

#### 查看部分文件（tail、head）

1. tail

tail命令默认情况下会显示文本末尾10行：

```shell
tail file
```

-n参数修改所显示的行数（显示2行）：

```shell
tail -n 2 file
```

-f参数会使tail命令保持活动状态，并不断显示添加到文件中的内容：

```shell
tail -f file
```

2. head

head命令默认情况下会显示文本头10行：

```shell
head file
```

-n参数修改所显示的行数（显示2行）：

```shell
head -n 2 file
```

## 更多的bash shell命令

### 检测程序

#### 探查进程（ps）

Linux系统中使用的GNU ps命令支持3种不同类型的命令行参数：

- Unix风格的参数，前面加单破折线；
- BSD风格的参数，前面不加破折线；
- GNU风格的长参数，前面加双破折线。

**Unix风格的参数**

|      参数       |                描述                |
| :-----------: | :------------------------------: |
|      -A       |              显示所有进程              |
|      -N       |          显示于指定参数不符的所有进程          |
|      -a       |       显示除控制进程和无终端进程外的所有进程        |
|      -d       |          显示除控制进程外所有的进程           |
|      -e       |              显示所有进程              |
| -C *cmdlist*  |       显示包含在*cmdlist*列表种的进程       |
| -G *grplist*  |      显示组ID在*grplist*列表种的进程       |
| -U *userlist* |    显示属主的用户ID在*userlist*列表中的进程    |
| -g *grplist*  |     显示会话或组ID在*grplist*列表中的进程     |
| -p *pidlist*  |      显示PID在*pidlist*列表中的进程       |
| -s *sesslist* |      显示会话ID在sesslist列表中的进程       |
| -t *ttylist*  |       显示终端ID在ttylist列表中的进程       |
| -u *userlist* |     显示有效用户ID在userlist列表中的进程      |
|      -F       |       显示更多额外输出（相对于-f参数而言）        |
|  -O *format*  |     显示默认的输出列以及format列表指定的特定列     |
|      -M       |            显示进程的安全信息             |
|      -c       |           显示进程的额外调度器信息           |
|      -f       |            显示完整格式的输出             |
|      -j       |              显示任务信息              |
|      -l       |              显示长列表               |
|  -o *format*  |          仅显示format指定的列           |
|      -y       | 不要显示进程标记（process flag，表明进程状态的标记） |
|      -z       |             显示安全标签信息             |
|      -H       |      用层级格式来显示进程（树状，用来显示父进程）      |
| -n *namelist* |          定义了WCHAN列显示的值           |
|      -w       |          采用宽输出模式，不限宽度显示          |
|      -L       |             显示进程中的线程             |
|      -V       |            显示ps命令的版本号            |

```shell
ps -ef
```

这些扩展的列包含了有用的信息：

- UID：启动这些进程的用户
- PID：进程的进程ID
- PPID：父进程的进程号（如果该进程是由另一个进程启动的）
- C：进程生命周期中的CPU利用率
- STIME：进程启动时的系统时间
- TTY：进程启动时的终端设备
- TIME：运行进程需要的累计CPU时间
- CMD：启动的程序名称

```shell
ps -l
```

使用-l多处的列：

- F：内核分配给进程的系统标记
- S：进程的状态（O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，进程已结束但父进程已不存在；T代表停止）
- PRI：进程的优先级（越大的数字代表越低的优先级）
- NI：谦让度值用来参与决定优先级
- ADDR：进程的内存地址
- SZ：加入进程被换出，所需交换空间的大致大小
- WCHAN：进程休眠的内核函数的地址

#### 实时监测进程（top）

输出的第一部分显示的时系统的概况：

第一行显示了当前时间、系统的运行时间、登陆的用户数以及系统的平均负载（平均负载由3个值：最近1m的，最近5m的和最近15m的）。

第二行显示了进程概要信息，有多少个进程处在运行、休眠、停止或是僵化状态（僵化状态是进程完成了，但父进程没有响应）。

第三行显示了CPU的概要信息。top根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出。

紧跟其后的两行说明了系统内存的状态。第一行说的是系统的物理内存：总共由多少内存，当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间的状态而言的。

最后一部分显示当前运行中的进程的详细列表。

- PID：进程的ID
- USER：进程属主的名字
- PR：进程的优先级
- NI：进程的谦让度值
- VIRT：进程占用的虚拟内存总量
- RES：进程占用的物理内存总量
- SHR：进程和其他进程共享的内存总量
- S：进程的状态（D代表中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表跟踪状态或停止状态，Z代表僵化状态）
- %CPU：进程使用的CPU时间比例
- %MEM；进程使用的内存占可用内存的比例
- TIME+：自进程启动到目前位置的CPU时间总量
- COMMAND：进程所对应的命令行名称，也就是启动的程序名

在top命令运行时键入交互式命令可改变top的行为：键入f允许选择对输出进行排序的字段，键入d允许修改轮询间隔，键入q可以退出top。

#### 结束进程（kill，killall）

在Linux中，进程之间通过**信号**来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是做出反应。

|  信号  |  名称  |        描述        |
| :--: | :--: | :--------------: |
|  1   | HUP  |        挂起        |
|  2   | INT  |        中断        |
|  3   | QUIT |       结束运行       |
|  9   | KILL |      无条件终止       |
|  11  | SEGV |       段错误        |
|  15  | TERM |      尽可能终止       |
|  17  | STOP |   无条件停止运行，但不终止   |
|  18  | TSTP |  停止或暂停，但继续在后台运行  |
|  19  | CONT | 在STOP或TSTP之后恢复执行 |

1.kill命令

kill命令可通过进程ID（PID）给进程发信号。默认情况下，kill命令会向命令行中列出的全部PID发送一个TERM信号。要发送进程信号，你必须是进程的属主或登陆为root用户。

```shell
kill pid
kill -15 pid
```

2.killall命令

killall命令支持通过进程名而不是PID来结束进程。killall命令也支持通配符。

```shell
killall http*
```

### 监测磁盘空间

#### 挂载存储媒体（mount，umount）

Linux文件系统将所有的磁盘都并入一个虚拟目录下，在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作成为挂载。

1.mount命令

Linux上用来挂载媒体的命令叫做mount。默认情况下，mount命令会输出当前系统上挂载的设备列表。

```shell
mount
```

mount命令提供如下四部分信息：

- 媒体的设备文件名
- 媒体挂载到虚拟目录的挂载点
- 文件系统类型
- 已挂载媒体的访问状态

手动在虚拟目录中挂载设备，需要以root用户身份登陆，或是以root用户身份运行sudo命令。基本命令：

```shell
mount -t type device directory 
```

媒体设备挂载到了虚拟目录后，root用户就有了对该设备的所有访问权限，而其他用户的访问会被限制。

|     参数     |                  描述                   |
| :--------: | :-----------------------------------: |
|     -a     |       挂载/etc/fstab文件中指定的所有文件系统        |
|     -f     |        使mount命令模拟挂载设备，但并不真的挂载         |
|     -F     |        和-a参数一起使用时，会同时挂载所有文件系统         |
|     -v     |           详细模式，将会说明挂载设备的每一步           |
|     -I     | 不启用任何/sbin/mount.filesystem下的文件系统帮助文件 |
|     -l     |     给ext2、ext3或XFS文件系统自动添加文件系统标签      |
|     -n     |      挂载设备，但不注册到/etc/mtab已挂载设备文件中      |
|  -p *num*  |       进行加密挂在时，从文件描述符num中获得密码短语        |
|     -s     |            忽略该文件系统不支持的挂载选项            |
|     -r     |               将设备挂载为只读的               |
|     -w     |           将设备挂载为可读写的（默认参数）            |
| -L *label* |           将设备按指定的*label*挂载            |
| -U *uuid*  |            将设备按指定的*uuid*挂载            |
|     -O     |     和-a参数一起使用，限制命令只作用到特定的一组文件系统上      |
|     -o     |             给文件系统添加特定的选项              |

-o参数允许在挂载文件系统时添加一些以逗号分隔的额外选项：

- ro：以只读形式挂载
- rw：以读写形式挂载
- user：允许普通用户挂载文件系统
- check=none：挂载文件系统时不进行完整性校验
- loop：挂载一个文件

2.umount命令

从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。

```shell
umount [directory | device]
```

#### 使用df命令

df命令可以很方便的查看多有已挂载磁盘的使用情况。

```shell
df
```

命令输出格式如下：

- 设备的设备文件位置
- 能容纳多少个1024字节大小的块
- 已用了多少个1024字节大小的块
- 还有多少个1024字节大小的块可用
- 已用空间所占的比例
- 设备挂载到了哪个挂载点上

-h把输出中的磁盘空间按照用户易读的形式显示：

```shell
df -h
```

####使用du命令

du命令可以显示某个特定目录（默认情况下时当前目录）的磁盘使用情况。默认情况下，du命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，它会以磁盘块为单位来表明每个文件或目录占用了多大存储空间。

```shell
du
```

-c参数可以显示所有已列出文件总的大小：

```shell
du -c
```

-h参数按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节：

```shell
du -h
```

-s参数显示每个输出参数的总计：

```shell
du -s
```



































