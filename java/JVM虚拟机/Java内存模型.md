# Java内存模型

## 并发编程模型的分类

并发编程中，需要考虑两个问题：线程之间如何通信及线程之间如何同步。

- 通信是指线程之间以何种机制来交换信息。
- 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。

在命令式编程中，线程之间的通信机制有两种：**共享内存和消息传递**。

Java的并发采用的是共享内存模型，Java线程之间通过写-读内存中的公共状态来隐式进行通信，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。

## Java内存模型的抽象

在Java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享，有内存可见性的问题。局部变量、方法定义参数和异常处理器参数不会在线程之间共享，不会有内存可见性问题。

Java线程之间的通信由Java内存模型（简称JMM）控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见，从而为Java程序员提供内存可见性保证。

从抽象的角度看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存存储了该线程以读/写共享变量的副本。

本地内存是JMM的抽象概念，不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

![JMM](./img/JMM.jpg)

## 重排序

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行重排序。现代处理器采用了指令级并行技术来讲多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令对的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能实在乱序执行。

![三种重排序](./img/三种重排序.jpg)

上述1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。

对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器生成指令序列时，插入特定类型的内存屏障来禁止特定类型的处理器重排序。

## 内存屏障

为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。

JMM把内存屏障指令分为4类：

|        屏障类型         |           指令示例           |                    说明                    |
| :-----------------: | :----------------------: | :--------------------------------------: |
|  LoadLoad Barriers  |   Load1;LoadLoad;Load2   |     确保Load1数据的装载先于Load2及所有后续装载指令的装载      |
| StoreStore Barriers | Store1;StoreStore;Store2 | 确保Store1数据对其他处理器可见（刷新到主内存）先于Store2及所有后续存储指令的存储 |
| LoadStore Barriers  |  Load1;LoadStore;Store2  |    确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存    |
| StoreLoad Barriers  |  Store1;StoreLoad;Load2  | 确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令 |

StoreLoad Barriers同时具有其他3个屏障的效果。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中。

## happens-before

在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以实在一个线程之内，也可以在不同线程之间。

与程序员密切相关的happens-before规则如下：

- 程序顺序规则：一个线程中的每个操作，happens-before于该线程中对的任意后续操作。
- 监视器锁规则：对一个监视器的解锁，happens-before于随后对这个监视器的加锁。
- volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
- 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

注：两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行。happens-before仅仅要求前一个操作执行结果对后一个 操作可见。

一个happens-before规则对应于一个或多个编译器和处理器重排序规则。

## 数据依赖性

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

注：这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。

## as-if-serial语义

即时编译器和处理器需要保证程序能够遵守as-if-serial语义。通俗的说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要于顺序执行的结果保持一致。

如果两个操作之间存在数据依赖，那么即时编译器和处理器不能调整他们的顺序，否则将会造成程序语义的改变。

