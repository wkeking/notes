# Java内存模型

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

此处的变量与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。

## 主内存与工作内存

Java内存模型规定了所有的变量都存储在主内存中（此处的主内存仅是虚拟机内存的一部分）。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

工作内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

这里所说的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

## 内存间的交互操作

### 8种基本操作

主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了8种操作来完成，虚拟机实现时必须保证每一种操作都是原子的、不可再分的。

- lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

### 8种基本操作规则

- 如果要把一个变量从主内存复制到工作内存，就要顺序的执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序的执行store和write操作。Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。
- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程地工作内存同步回主内存中。
- 一个新的变量只能在主内存中产生，不允许在工作内存中直接使用一个未被初始化变量，也就是没有执行load或者assign操作。也就是说对一个变量实施use、store之前必须先执行过了load和assign操作。
- 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
- 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store、write操作。

## 重排序

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型：

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从Java源代码到最终实际执行的指令序列，会分别经历下面三种重排序。

![重排序](./img/重排序顺序.jpg)

上述1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。

## 内存屏障

为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。

JMM把内存屏障指令分为4类：

|        屏障类型         |           指令示例           |                    说明                    |
| :-----------------: | :----------------------: | :--------------------------------------: |
|  LoadLoad Barriers  |   Load1;LoadLoad;Load2   |     确保Load1数据的装载先于Load2及所有后续装载指令的装载      |
| StoreStore Barriers | Store1;StoreStore;Store2 | 确保Store1数据对其他处理器可见（刷新到主内存）先于Store2及所有后续存储指令的存储 |
| LoadStore Barriers  |  Load1;LoadStore;Store2  |    确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存    |
| StoreLoad Barriers  |  Store1;StoreLoad;Load2  | 确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令 |

StoreLoad Barriers同时具有其他3个屏障的效果。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中。

## as-if-serial

即时编译器和处理器需要保证程序能够遵守as-if-serial属性。通俗的说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要于顺序执行的结果保持一致。

如果两个操作之间存在数据依赖，那么即时编译器和处理器不能调整他们的顺序，否则将会造成程序语义的改变。

## 先行发生原则（happens-before）

**先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，影响包括修改了内存中共享变量的值、发送了消息、调用了方法等。**

**简单来说，先行发生原则是用来描述两个操作的内存可见性的。如果操作X happens-before 操作Y，那么X的结果对于Y可见。**

在同一个线程中，字节码的先后顺序暗含了happens-before关系：在程序控制流路径中靠前的字节码happens-before靠后的字节码。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者没有观测前者的运行结果，即后者没有数据依赖于前者，那么他们可能会被重排序。

先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，可以通过几条规则一揽子的解决并发环境下两个操作之间是否可能存在冲突的所有问题。

单线程的规则：

- 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

两个线程间的规则：

- 监视器锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而后面是指时间上的先后顺序。
- volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序。
- 线程启动规则：如果线程A执行操作ThreadB.start()（启动线程B），那么线程A的ThreadB.start()操作先行发生于线程B中的任意操作。
- 线程终止规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作先行发生于线程A从ThreadB.join()操作成功返回。
- 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
- 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

*注：时间上的先后顺序指的是a线程操作，之后b线程操作能观测到a操作的结果。*

**时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。**

## volatile内存语义

当一个变量定义为volatile之后，它将具备两种特性：

- 保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。

  volatile变量在各个线程的工作内存中不存在一致性问题，原因是在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在不一致性问题。但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。

- 禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓"线程内表现为串行的语义"（Within-Thread As-If-Serial Semantics）。

### volatile写-读内存语义

- volatile写内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。
- volatile读内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

### volatile内存语义实现

- 在每个volatile写操作的前面插入一个StoreStore屏障

  StoreStore禁止上面的普通写和下面的volatile写重排序

- 在每个volatile写操作的后面插入一个StoreLoad屏障

  StoreLoad防止上面的volatile写与下面可能有的volatile读/写重排序

- 在每个volatile读操作的后面插入一个LoadLoad屏障

  LoadLoad禁止下面所有的普通读操作和上面的volatile读重排序

- 在每个volatile读操作的后面插入一个LoadStore屏障

  LoadStore禁止下面所有的普通写操作和上面的volatile读重排序

### Java内存模型对volatile变量定义的特殊规则

假定T表示一个线程，V和M分别表示两个volatile型变量，那么在进行read、load、use、assign、store、write操作时需要满足如下规则：

- 只有当前线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（**这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所作的修改后的值**）。
- 只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现（**这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改**）。
- 假定动作A是线程T对变量V实施的use或assing动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相对应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read和write动作。如果A先于B，那么P先于Q（**这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同**）。

### 在众多并发安全的工具中选择volatile的意义

volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的要求。

## 锁的内存语义

### 锁的释放和获取的内存语义

- 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中
- 当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量

### 锁内存语义的实现

锁的实现依赖于Java同步器框架AbstractOueuedSynchronizer。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，这个volatile变量是锁内存语义实现的关键。

- 当线程获取锁时，加锁方法首先读volatile变量state

- 当线程释放锁时，

  1. 公平锁在释放锁的最后写volatile变量state

     根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。

  2. 非公平锁以CAS操作的方式更新state变量

     JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。

     CAS操作是Unsafe类中native方法，该方法禁止该指令与之前和之后的读和写指令重排序，把写缓冲区中的所有数据刷新到内存中，所以该方法同时实现volatile读和写的内存语义。

对公平锁和非公平锁的内存语义总结：

- 公平锁和非公平锁释放时，最后都要写一个volatile变量state
- 公平锁获取时，首先去读volatile变量
- 非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和写的内存语义

## final域的内存语义

- 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
- 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序