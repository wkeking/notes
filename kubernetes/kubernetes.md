# Kubernetes

## 核心概念

Kubernetes为了更好的管理应用的生命周期，将不同资源对象进行了进一步的操作抽象。使用Kubernetes实际上就是要掌握这些不同的抽象对象。

Kubernetes中每种对象都拥有一个对应的声明式API。对象包括三大属性：元数据（metadata）、规范（spec）和状态（status）。元数据是用来标识API对象的，每个对象都至少有3个元数据：namespace、name和uid；除此之外还有各种各样的标签labels用来标识和匹配不同的对象，例如用户可以用标签env来标识区分不同的服务部署环境，分别用env=dev、env=testing、env=production来标识开发、测试、生产的不同服务。规范描述了用户期望K8s集群中的分布式系统达到的理想状态（Desired State），例如用户可以通过复制控制器Replication Controller设置期望的Pod副本数为3；status描述了系统实际当前达到的状态（Status），例如系统当前实际的Pod副本数为2；那么复制控制器当前的程序逻辑就是自动启动新的Pod，争取达到副本数为3。通过这三个属性，用户可以定义让某个对象处于给定的状态（如多少Pod运行在哪些节点上）以及表现策略（如如何升级、容错），而无须关心具体的实现细节。

##资源抽象对象

Kubernetes对集群中的资源进行了不同级别的抽象，每个资源都是一个REST对象，通过API进行操作，通过json或yaml格式的模板文件进行定义。

### 基本资源抽象对象

#### 容器组（Pod）

在Kubernetes中，并不直接操作容器，最小的管理单位时容器组（Pod）。容器组由一个或多个容器组成，Kubernetes围绕容器组进行创建、调度、停止等生命周期管理。

同一个容器组中，各个容器共享命名空间（包括网络、IPC、文件系统等容器支持的命名空间）、cgroups限制和存储卷。这意味着同一个容器组中，各个应用可以很方便的相互进行访问，比如通过localhost地址进行网络访问，通过信号量和共享内存进行进程间通信等，类似经典场景中运行在同一个操作系统中的一组进程。可以简单的将一个Pod当作是一个抽象的虚拟机，里面运行若干个不同的进程（每个进程实际上就是一个容器）。

实现上，是先创建一个gcr.io/google_containers/pause容器，创建相关命名空间，然后创建Pod中的其他应用容器，并共享pause容器的命名空间。

组成容器组的若干容器往往是存在共同的应用目的，彼此关联十分紧密。可以说，容器组既保持了容器轻量解耦的特性，又提供了调度操作的便利性，在实践中提供了比单个容器更为灵活和更有意义的抽象。

容器组生命周期包括五种状态值：待定、运行、成功、失败、未知。

- 待定（Pending）：已经被系统接受，但容器镜像还未就绪；
- 运行（Running）：分配到节点，所有容器都被创建，至少一个容器在运行中；
- 成功（Succeeded）：所有容器都正常退出，不需要重启，任务完成；
- 失败（Failed）：所有容器都退出，至少一个容器是非正常退出；
- 未知（Unknown）：未知状态，例如所在节点无法汇报状态。


#### 服务（Service）

服务的提出，主要是要解决Pod地址可变的问题。由于Pod随时可能发生故障，并可能在其他节点上被重启，它的地址是不可能被固定的。因此，用一个服务来代表提供某一类功能（可以通过标签来筛选）的一些Pod，并分配不随Pod位置变化而改变的虚拟访问地址（Cluster IP）。

典型的情况，比如网站的后端服务，可能有多个Pod都运行了后端处理程序，他们可能组成一个服务。前端只需要通过服务的唯一虚拟地址来访问即可，而无须关心具体是访问到了哪个Pod。服务跟负载均衡器实现的功能很相似。

根据访问方式的不同，服务可以分为以下几种类型：

- ClusterIP：提供一个集群内部的地址，该地址只能在集群内部解析和访问。ClusterIP是默认的服务类型。
- NodePort：在每个集群节点上映射服务到一个静态的本地端口。从集群外部可以直接访问，并自动路由到内部自动创建的ClusterIP。
- LoadBalancer：使用外部的路由服务，自动路由访问到自动创建的NodePort和ClusterIP。
- ExternalName：将服务映射到externalName域指定的地址。

#### 存储卷（Volume）

存储卷即容器挂载的数据卷，跟Pod有一致的生命周期，Pod生存过程（包括重启）中，数据卷跟着存在；Pod退出，则数据卷跟着退出。

### 控制器抽象对象

#### 副本集（ReplicaSet）

在Kubernetes看来，Pod资源是可能随时发生故障的，并不需要保证Pod的运行，而是在发生失败后重新生成。Kubernetes通过复制控制器来实现这一功能。

用户申请容器组后，复制控制器将负责调度容器组到某个节点上，并保证它的给定份数（replicaP）正常运行。当实际运行Pod份数超过数目，则终止某些Pod；当不足，则创建新的Pod。一般建议，即使Pod份数是1，也要使用复制控制器来创建，而不是直接创建Pod。

可以将副本集类比为进程的监管者的角色，只不过他不光能保持Pod的持续运行，还能保持集群中给定类型Pod同时运行的个数为指定值。

#### 部署（Deployment）

部署机制支持更灵活的Pod管理，从而用户无需直接跟复制控制器打交道了。部署代表用户对集群中应用的一次更新操作，在副本集的基础上还支持更新操作。每次滚动升级（rolling-update），会自动将副本集中旧版本的Pod逐渐替换为新的版本。

#### 副本控制器（Replication Controller）

副本控制器是确保用户定义的Pod副本书保持不变。

建议使用Deployment配置ReplicaSet方法来控制副本数。

#### 状态集（StatefulSet）

通常情况下，使用容器的应用都是不带状态的，意味着部署同一个应用的多个Pod彼此可以替换，而且生命周期可以实很短暂的。任何一个Pod退出后，Kubernetes在集群可以自动创建一个并按照调度策略调度到节点上。无状态的应用时候，关心的主要是副本的个数，而不关心名称、位置等。与此对应，某些应用需要关系Pod的状态（包括各种数据库和配置服务等），挂载独立的存储。一旦当某个Pod故障退出后，Kubernetes会创建同意命名的Pod，并挂载原来的存储，以便Pod中应用继续执行，实现了该应用的高可用性。

状态集正式针对这种需求而设计的，提供比副本集和部署更稳定可靠的运行支持。

#### Daemon集（DaemonSet）

Daemon集适合于长期运行在后台的伺服类型应用，例如对节点的日志采集或状态监控等后台支持服务。

Daemon集的应用会确保在指定类型的每个节点上都运行一个该应用的Pod。可能在集群中所有节点，也可能是指定标签的一类节点。

#### 任务（Job）

不同于长期运行的应用，任务（Job）代表批处理类型的应用。任务中应用完成某一类的处理即可退出，有头有尾。

#### 横向Pod扩展器（Horizontal Pod Autoscaler，HPA）

横向Pod扩展器解决应用波动的情况。类似云里面的自动扩展组，扩展器根据Pod的使用率（典型如CPU、内存等）自动调整一个部署里面Pod的个数，保障服务在不同压力情况下保证平滑的输出效果。

控制管理器会定期检查性能指标，在满足条件时候触发横向伸缩。

#### 入口控制器（Ingress Controller）

定义外部访问集群中资源的一组规则，用来提供七层代理和负载均衡服务。

通常情况下，Service和Pod仅可在集群内部网络中通过IP地址访问。所有到达边界路由器的流量或被丢弃或被转发到其他地方。Ingress是授权入站连接到达集群服务的规则集合。可以给Ingress配置提供外部可访问的URL、负载均衡、SSL、基于名称的虚拟主机等。用户通过POST Ingress资源到API Service的方式来请求Ingress。Ingress Controller负责实现Ingress，通常使用负载平衡器，它还可以配置边界路由和其他前端，这有助于以HA方式处理流量。

### 管理资源相关的辅助概念

#### 标签（Label）

标签是一组键值对，用来标记所绑定对象（典型的就是Pod）的识别属性，进而可以分类。比如name=apache|nginx、type=web|db、release=alpha|beta|stable。另外，Label键支持通过‘/’来添加前缀，可以用来标注资源的组织名称等。一般的前缀不能超过253个字符，键名不能超过63个字符。

标签所定义的属性是不唯一的，这意味着不同资源可能带有相同的标签键值对。这些属性可以将业务的相关信息绑定到对象上，用来对资源对象进行分类和选择过滤。

#### 选择器（Selector）

基于资源对象上绑定的标签信息，选择器可以通过指定标签键值对来过滤出一组特定的资源对象。

选择器支持的语法包括基于等式的（Equality-based），和基于集合的（Set-based）。

基于等式的选择，即通过指定某个标签是否等于某个值，例如evn=production或者tier！=frontend等。多个等式可以通过AND逻辑组合在一起。

基于集合的选择，即通过指定某个标签的值是否在某个集合内，例如env in （staging，production）。

#### 注解（Annotation）

注解跟标签很相似，也是键值对，但并非用来标识对象，同时可以存储更多更复杂的信息。不同的是，注解并不是为了分类资源对象，而实为了给对象增加更丰富的描述信息。这些信息是任意的，数据量可以很大，可以包括各种结构化、非结构化的数据。

常见的注解包括时间戳、发行信息、开发者信息等，一般是为了方便用户查找相关线索。

#### 秘密数据（Secret）

秘密数据资源用来保存一些蜜柑的数据，这些数据往往不希望别的用户看到，但是在启动启动资源的时候需要提供。通过把敏感数据放到Secret里面，用户值需要提供Secret的别名即可使用。

#### UID和名字（Name）

Kubernetes用UID和名字（Name）来标识对象。其中，UID是全局唯一的，并且不能复用；而名字则仅仅要求对某种类型的资源（在同一命名空间内）内唯一的，并且当某个资源移除后，其名字可以被新的资源复用。

这意味着，可以创建一个Pod对象，命名为test，同样可以创建一个复制控制器，明明也为test。一般的，名字字符串的长度不要超过253个字符。

####命名空间（Namespace）

命名空间（Namespace）用来隔离不同用户的资源，类似租户或项目的概念。默认情况下，相同命名空间中的对象将具有相同的访问控制策略。

同一个命名空间内，资源不允许重名，但不同命名空间之间，允许存在重名。用户在创建资源的时候可以通过

```shell
--namespace=<some_namespace>
```

来指定所属的命名空间。

Kubernetes集群启动后，会保留两个特殊的命名空间：

- default：资源未指定命名空间情况下，默认属于该空间；
- kube-system：由kubernetes系统自身创建的资源。

另外，大部分资源都属于某个命名空间，但部分特殊资源，如节点、持久存储等不属于任何命名空间。

#### 持久化存储（PersistentVolume）

持久化存储确保数据不会丢失。持久化的存储以插件的形式提供为PersistentVolume资源，用户通过请求某个类型PersistentVolumeClaim资源，来从匹配的持久化存储卷上获取绑定的存储。

#### 资源限额（Resource Quotas）

资源限额用来限制某个命名空间下对资源的使用，开始逐渐提供多租户支持。

#### 安全上下文（Security Context）

应用到容器上的系统安全配置，包括uid、gid、capabilities、SELinux角色等。

#### 服务账号（Service Accounts）

操作资源的用户账号。

####污点和容忍

污点（Taint）和容忍（Toleration）用于辅助管理Pod到工作节点的调度过程。具有某个污点的工作节点，在不容忍的Pod看来，要尽量避免调度到它上面去。

通常情况下，可以为一个工作节点标注若干污点，只有对这些污点容忍的Pod，才可以被调度到这些具有污点的节点上。

## 重要组件

Kubernetes集群采用了典型的“主-从”架构，由使用kubernetes组建管理的一组节点组成看，这些节点提供了容器资源池供用户使用。一个集群主要由管理节点（Master）和工作节点（Node）组建构成。Master系欸的那负责控制，Node节点负责干活，各自又通过若干组件组合实现。

- Master


Master节点负责协调集群中的管理活动，例如调度、监控、支持对资源的操作等，通过节点控制器来与工作节点交互。其中组件主要又Etcd、apiserver、scheduler、controller-manager，以及ui、DNS等可选插件。

这些组件可以任意部署在相同或者不同机器上，只要可以通过标准的HTTP接口可以相互访问到即可，这意味着对Kubernetes的管理组件进行扩展将变得十分简单。

- Nodes


Node节点是实际工作的计算实例。Node节点可以是虚拟机或者物理机器，在创建Kubernetes集群过程中，都要与预装一些必要的软件来响应Master的管理。目前，Node上至少包括容器环境（如Docker）、kubelet（跟Master节点通信）和Kube-Proxy（负责网络相关功能）。

Node节点邮几个重要的属性：地址信息（Address）、状态（Condition）、资源容量（Capacity）、节点信息（Info）。

#### Etcd

Kubernetes依赖Etcd数据库服务来记录所有节点和资源的状态。可以说，Etcd是Kubernetes集群中最重要的组件。apiserver的大量功能都是通过跟Etcd进行交互实现的。

#### kube-apiserver

作为REST API服务端，kube-apiserver接受来自客户端和其他组件的请求，更行Etcd中的数据，是响应对API资源操作的最前端组件。一般推荐部署多个kube-apiserver来提高可用性。

#### kube-scheduler

kube-scheduler负责具体的资源调度工作，对节点进行筛选和过滤。当资源请求被收到后，负责按照调度策略选择最合适的节点运行Pod。

#### kube-controller-manager

提供控制器服务，监视集群的状态，一旦不满足状态则采取操作，让状态恢复正常，常见的控制器包括：

- 复制（replication）控制器：确保指定Pod同时存在指定目录的实例；
- 端点（endpoint）控制器：负责Endpoints对象的创建、更新；
- 节点（node）控制器：负责节点的发现，管理和监控；
- 命名空间（namespace）控制器：响应对命名空间的操作，如创建、删除等；
- 服务账户（ServiceAccounts）控制器：管理命令空间中的ServiceAccount，确保默认账户存在于每个正常的命名空间中。

#### kubelet

kubelet是Node节点上最重要的工作程序，它是负责具体干活的，将给定的Pod运行在自己负责的节点上。如果kubelet出现故障，则kubernetes将认为该Node变得不可用。因此，在生产环节中推荐对kubelet进程进行监控，并通过诸如supervisord这样的软件来及时重启故障的进程。另外，一般要通过-system-reserved和-kube-reserved参数为系统和Kubernetes组件预留出运行资源，避免耗尽后让节点挂掉。

#### kube-proxy

kube-proxy会在每一个Node节点上监听，负责把对应服务端口来的通信映射给后端对应的Pod。简单的说，它既是一个NAT（支持TCP和UDP），同时也有负载均衡（目前仅支持TCP）的功能。